# CAN Bus Scheduler

 A multi-threaded TCP server and companion client for scheduling recurring or one-shot `cansend` transmissions on Linux CAN/vCAN interfaces.

Notes on recent changes:
- Scheduler refactor: the ThreadPool now uses a dedicated timer thread and an `enqueue_after` API for delayed work (replaces older deadline-in-worker logic). Priority + FIFO semantics are preserved.
- Restart: the `RESTART` client command is implemented; it requests a graceful shutdown and re-execs the server binary so the process restarts in-place.
- Logging: log path can be set via `LOG_PATH=` in the server config or via the `SERVER_LOG_PATH` environment variable. On Android the default log path is `/data/local/tmp/server/server.log`.

## Features
- Deadline + priority thread pool for CAN message scheduling.
- Support for recurring (`CANSEND#...`) and single-shot (`SEND_TASK#...`) jobs.
- Per-client task management (pause/resume/kill/list).
- Dynamic discovery of available CAN interfaces.
- Centralized logging with configurable verbosity.

## Repository Layout
- `server.cpp` — TCP server, command dispatcher, scheduling logic, CAN discovery.
- `client.cpp` — interactive CLI client for sending commands.
- `test_server.cpp` — unit tests for command parsing.
- `test_integration.cpp` — lightweight integration test harness.
- `output/server.conf` & `output/client.conf` — example configuration files.
- `Makefile` — build targets for server, client, and tests.

## Prerequisites
- Linux with POSIX sockets and pthreads.
- `g++` supporting C++20.
- `iproute2` and CAN utils (`cansend`, `candump`).
- Optional: virtual CAN setup for local testing.

### Creating a vCAN interface
```bash
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
```

## Build
```bash
make all         # build server -> output/server
make client      # build client -> output/client
make test        # build & run test_server.cpp
make clean       # remove binaries
```

## Configuration
### Server (`output/server.conf`)
```
PORT=50123
LOG_LEVEL=DEBUG        # DEBUG|INFO|WARNING|ERROR|NOLOG
WORKER_THREADS=2       # optional, defaults to min(cores, value) with floor of 1
LOG_PATH=/var/log/canserver/server.log  # optional: overrides default log path (./server.log). SERVER_LOG_PATH env overrides all
USE_RAW_CAN=true       # optional: true = use raw CAN sockets (faster, falls back to cansend on error), false = always use cansend. Default: true
USE_PERSISTENT_SHELL=false  # optional: true = use persistent shell for cansend (fastest cansend method), false = vfork/exec per send. Default: false
```

**Performance comparison:**
- `USE_RAW_CAN=true`: (fastest (~850+ msgs per second), super fast, requires raw socket support)
- `USE_PERSISTENT_SHELL=true`: (~425 msgs per second, works everywhere with cansend. Bad debugging, and slower)
- Default (vfork/exec): (~550 msgs per second, very good speed with great debugging)
- Leave both false for best experience unless you need speed.

**Send method priority:**
1. Raw CAN sockets (tried first if `USE_RAW_CAN=true`)
2. Persistent shell (if `USE_PERSISTENT_SHELL=true` and raw sockets failed/disabled)
3. vfork/exec (final fallback)

**Recommended configurations:**
- For maximum speed on systems with raw socket support: `USE_RAW_CAN=true` (default)
- For systems without raw sockets but needing high speed: `USE_RAW_CAN=false` + `USE_PERSISTENT_SHELL=true`
- For maximum compatibility: both false (uses vfork/exec)
```

### Client (`output/client.conf`)
```
SERVER_IP=127.0.0.1
SERVER_PORT=50123
```

## Running

### Basic (two terminals)
Terminal 1:
```bash
./output/server output/server.conf
```

Terminal 2:
```bash
./output/client output/client.conf
```

### Using tmux (recommended for SSH sessions)
Tmux keeps your server running even if your SSH connection drops.

```bash
# Start a new tmux session
tmux new -s canserver

# Run the server
./output/server output/server.conf

# Detach from session: Press Ctrl+b, then d
# Server continues running in background

# Open client in a new terminal
./output/client output/client.conf

# Reattach to server session anytime
tmux attach -t canserver

# List all sessions
tmux ls

# Kill session when done
tmux kill-session -t canserver
```

## Protocol Reference
- `CANSEND#<id>#<payload>#<interval_ms>#<bus>[#priority]` — recurring transmissions.
- `SEND_TASK#<id>#<payload>#<delay_ms>#<bus>[#priority]` — one-shot transmission.
- `LIST_TASKS`, `PAUSE <task_id>`, `RESUME <task_id>`, `KILL_TASK <task_id>`, `KILL_ALL_TASKS`.
- `LIST_CAN_INTERFACES` — refreshes and lists CAN/vCAN devices.
- `notice me senpai` — will senpai notice you?
- `SET_LOG_LEVEL <level>`, `LIST_THREADS`, `KILL_THREAD <id>`, `KILL_ALL`, `SHUTDOWN`, `RESTART`.

Priority defaults to 5 and accepts digits `0–9` (higher runs earlier when deadlines tie). `interval_ms`/`delay_ms` accept optional `ms` suffix.

- Runtime logs are appended to the configured log path. Priority for selecting where logs go:
	1. `SERVER_LOG_PATH` environment variable (if set)
	2. `LOG_PATH=` in the server configuration file
	3. Platform default (`server.log` in CWD on Linux, `/data/local/tmp/server/server.log` on Android)
- The server will attempt to create parent directories for the configured `LOG_PATH` and will fall back to stderr if it cannot write logs.
- `LIST_TASKS` returns status plus error strings for failed tasks.
- Child process failures (non-zero exit, signal) are tracked per task.

## Testing & Diagnostics
- `make test` runs parsing unit tests (gtest not required).
- `test_integration.cpp` expects a running server on `127.0.0.1:50123`.
- Use `candump -tz vcan0` to verify transmitted frames on vCAN.

## Troubleshooting
- **No CAN interfaces**: ensure `vcan0` exists or physical CAN devices are up.
- **`cansend` not found**: install `can-utils` and confirm it is on `PATH`.
- **Fork failures**: check system process limits (`ulimit -u`).
- **Permission denied**: bring interfaces up as root or with appropriate capabilities.

## License
MIT — see [LICENSE](./LICENSE).



